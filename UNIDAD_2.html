<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unidad II - Trabajos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }

        .header h1 {
            color: #764ba2;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .btn-volver {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            margin-bottom: 20px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            font-weight: bold;
        }

        .btn-volver:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        .trabajos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }

        .trabajo-card {
            background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .trabajo-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.25);
        }

        .trabajo-card h3 {
            color: #5e35b1;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .trabajo-card p {
            color: #333;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .codigo-container {
            background: #1e1e1e;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            position: relative;
        }

        .codigo-container pre {
            color: #d4d4d4;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .codigo-container code {
            color: #9cdcfe;
        }

        .btn-descargar, .btn-ver-pdf {
            display: inline-block;
            padding: 10px 25px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            text-decoration: none;
            border-radius: 20px;
            margin-top: 15px;
            margin-right: 10px;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .btn-descargar:hover, .btn-ver-pdf:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(245, 87, 108, 0.4);
        }

        .btn-toggle-codigo {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 10px;
            margin-right: 10px;
            transition: all 0.3s ease;
        }

        .btn-toggle-codigo:hover {
            background: #764ba2;
            transform: scale(1.05);
        }

        .codigo-oculto {
            display: none;
        }

        .etiqueta {
            display: inline-block;
            background: rgba(94, 53, 177, 0.2);
            color: #5e35b1;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.85em;
            margin: 5px 5px 10px 0;
            font-weight: bold;
        }

        .botones-container {
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            .trabajos-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="btn-volver">‚Üê Volver al inicio</a>
        
        <div class="header">
            <h1>üìö Unidad II: M√©todos Avanzados y Aplicaciones</h1>
        </div>

        <div class="trabajos-grid">
            <!-- Trabajo 1 -->
            <div class="trabajo-card">
                <h3>Trabajo 1: INDICE H</h3>
                <div class="etiqueta">Python</div>
                <div class="etiqueta"> DOCENTES CON INDICE ALTO</div>
                <p>El √≠ndice H (o √≠ndice de Hirsch) es un indicador utilizado para medir la productividad cient√≠fica y el impacto de un investigador, grupo o instituci√≥n. Se basa en la cantidad de publicaciones y el n√∫mero de citas que estas reciben. Un autor tiene un √≠ndice H igual a h si ha publicado h art√≠culos que han sido citados al menos h veces cada uno.</p>
                
                <div class="botones-container">
                    <a href="#" class="btn-ver-pdf">üìÑ Ver PDF</a>
                    <a href="#" class="btn-descargar" download>üì• Descargar PDF</a>
                </div>
            </div>

            <!-- Trabajo 2 -->
            <div class="trabajo-card">
                <h3>Trabajo 2: METODO DE BISECCION</h3>
                <div class="etiqueta">Python</div>
                <p>El m√©todo de bisecci√≥n es un procedimiento iterativo empleado para encontrar una ra√≠z real de una funci√≥n continua f(x) dentro de un intervalo cerrado [a, b] en el cual la funci√≥n cambia de signo, es decir, f(a) ¬∑ f(b) < 0. El m√©todo se fundamenta en el teorema del valor intermedio, que garantiza la existencia de al menos una ra√≠z en dicho intervalo.</p>
                
                <button class="btn-toggle-codigo" onclick="toggleCodigo('codigo2')">Ver C√≥digo</button>
                
                <div id="codigo2" class="codigo-container codigo-oculto">
                    <pre><code>
# M√©todo de Bisecci√≥n 
def biseccion(f, a, b, tol=1e-6, max_iter=100): 
    """ 
    Encuentra la ra√≠z usando el m√©todo de bisecci√≥n 
    f: funci√≥n 
    a, b: intervalo inicial [a, b] 
    tol: tolerancia 
    max_iter: n√∫mero m√°ximo de iteraciones 
    """ 
    print("\n=== M√âTODO DE BISECCI√ìN ===") 
    
    # Verificar que hay cambio de signo 
    if f(a) * f(b) > 0: 
        print("Error: f(a) y f(b) deben tener signos opuestos") 
        return None 
    
    print(f"{'Iter':<6} {'a':<15} {'b':<15} {'c':<15} {'f(c)':<15} {'Error':<15}") 
    print("-" * 90) 
    
    for i in range(max_iter): 
        c = (a + b) / 2 
        fc = f(c) 
        error = abs(b - a) / 2 
        
        print(f"{i+1:<6} {a:<15.8f} {b:<15.8f} {c:<15.8f} {fc:<15.8e} {error:<15.8e}") 
        
        if error < tol or abs(fc) < tol: 
            print(f"\nConvergi√≥ en {i+1} iteraciones") 
            print(f"Ra√≠z aproximada: x = {c:.8f}") 
            return c 
        
        # Actualizar intervalo 
        if f(a) * fc < 0: 
            b = c 
        else: 
            a = c 
    
    print(f"\nNo convergi√≥ en {max_iter} iteraciones") 
return c 
# Ejemplo de uso: Encontrar ra√≠z de x^2 - 2 = 0 
def f(x): 
return x**2 - 2 
# Ejecutar 
raiz = biseccion(f, 1, 2) )</code></pre>
                </div>
                
                <div class="botones-container">
                    <a href="#" class="btn-ver-pdf">üìÑ Ver PDF</a>
                    <a href="#" class="btn-descargar" download>üì• Descargar PDF</a>
                </div>
            </div>

            <!-- Trabajo 3 -->
            <div class="trabajo-card">
                <h3>Trabajo 3: METODO DE LA SECANTE</h3>
                <div class="etiqueta">Python</div>
                <div class="etiqueta">METODO DE LA SECANTE</div>
                <p>El m√©todo de la Secante es un procedimiento num√©rico iterativo empleado para aproximar las ra√≠ces reales de una funci√≥n continua f(x). A diferencia del m√©todo de Newton-Raphson, este m√©todo no requiere el c√°lculo de la derivada anal√≠tica, ya que la pendiente se aproxima usando dos puntos consecutivos cercanos a la ra√≠z.</p>
                
                <button class="btn-toggle-codigo" onclick="toggleCodigo('codigo3')">Ver C√≥digo</button>
                
                <div id="codigo3" class="codigo-container codigo-oculto">
                    <pre><code>
# M√©todo de la Secante 
def secante(f, x0, x1, tol=1e-6, max_iter=100): 
""" 
Encuentra la ra√≠z usando el m√©todo de la secante 
f: funci√≥n 
x0, x1: dos valores iniciales 
tol: tolerancia 
max_iter: n√∫mero m√°ximo de iteraciones 
    """ 
    print("\n=== M√âTODO DE LA SECANTE ===") 
    print(f"{'Iter':<6} {'x_n-1':<15} {'x_n':<15} {'x_n+1':<15} {'f(x_n+1)':<15} {'Error':<15}") 
    print("-" * 95) 
    
    for i in range(max_iter): 
        fx0 = f(x0) 
        fx1 = f(x1) 
        
        # Evitar divisi√≥n por cero 
        if abs(fx1 - fx0) < 1e-12: 
            print("\nError: Divisi√≥n por cero") 
            return x1 
        
        # F√≥rmula de la secante 
        x2 = x1 - fx1 * (x1 - x0) / (fx1 - fx0) 
        fx2 = f(x2) 
        error = abs(x2 - x1) 
        
        print(f"{i+1:<6} {x0:<15.8f} {x1:<15.8f} {x2:<15.8f} {fx2:<15.8e} {error:<15.8e}") 
        
        if error < tol or abs(fx2) < tol: 
            print(f"\nConvergi√≥ en {i+1} iteraciones") 
            print(f"Ra√≠z aproximada: x = {x2:.8f}") 
            return x2 
    
        # Actualizar valores 
        x0 = x1 
        x1 = x2 
    
    print(f"\nNo convergi√≥ en {max_iter} iteraciones") 
    return x2 

# Ejemplo de uso: Encontrar ra√≠z de x^2 - 2 = 0 
def f(x): 
    return x**2 - 2 

# Ejecutar 
raiz = secante(f, 1, 2)()</code></pre>
                </div>
                
                <div class="botones-container">
                    <a href="#" class="btn-ver-pdf">üìÑ Ver PDF</a>
                    <a href="#" class="btn-descargar" download>üì• Descargar PDF</a>
                </div>
            </div>

            <!-- Trabajo 4 -->
            <div class="trabajo-card">
                <h3>Trabajo 4: METODO DE PUNTO FIJO</h3>
                <div class="etiqueta">Python</div>
                <div class="etiqueta">metodo de punto fiijo</div>
                <p>El m√©todo del Punto Fijo es una t√©cnica iterativa utilizada para encontrar soluciones aproximadas de ecuaciones no lineales de la forma f(x) = 0. Se basa en reescribir la ecuaci√≥n en una forma equivalente:</p>
                
                <button class="btn-toggle-codigo" onclick="toggleCodigo('codigo4')">Ver C√≥digo</button>
                
                <div id="codigo4" class="codigo-container codigo-oculto">
                    <pre><code>def punto_fijo(g, x0, tol=1e-6, max_iter=100): 
""" 
    Encuentra la ra√≠z usando el m√©todo de punto fijo 
    g: funci√≥n de iteraci√≥n g(x) 
    x0: valor inicial 
    tol: tolerancia 
    max_iter: n√∫mero m√°ximo de iteraciones 
    """ 
    print("\n=== M√âTODO DE PUNTO FIJO ===") 
    print(f"{'Iter':<6} {'x':<15} {'g(x)':<15} {'Error':<15}") 
    print("-" * 55) 
    x = x0 
    for i in range(max_iter): 
        x_nuevo = g(x) 
        error = abs(x_nuevo - x) 
        
        print(f"{i+1:<6} {x:<15.8f} {x_nuevo:<15.8f} {error:<15.8e}")   
        if error < tol: 
            print(f"\nConvergi√≥ en {i+1} iteraciones") 
            print(f"Ra√≠z aproximada: x = {x_nuevo:.8f}") 
            return x_nuevo 
        x = x_nuevo 
    print(f"\nNo convergi√≥ en {max_iter} iteraciones") 
    return x 
def g(x): 
    return (x + 2/x) / 2 
# Ejecutar con un valor inicial cercano a sqrt(2) 
raiz = punto_fijo(g, 1.5)</code></pre>
                </div>
                
                <div class="botones-container">
                    <a href="#" class="btn-ver-pdf">üìÑ Ver PDF</a>
                    <a href="#" class="btn-descargar" download>üì• Descargar PDF</a>
                </div>
            </div>

            <!-- Trabajo 5 -->
            <div class="trabajo-card">
                <h3>Trabajo 5: METODO DE REGULA FALSI</h3>
                <div class="etiqueta">Python</div>
                <p>Implementaci√≥n del m√©todo de m√≠nimos cuadrados para el ajuste de datos experimentales.</p>
                
                <button class="btn-toggle-codigo" onclick="toggleCodigo('codigo5')">Ver C√≥digo</button>
                
                <div id="codigo5" class="codigo-container codigo-oculto">
                    <pre><code># M√©todo de la Falsa Posici√≥n (Regla Falsi) 
def falsa_posicion(f, a, b, tol=1e-6, max_iter=100): 
""" 
    Encuentra la ra√≠z usando el m√©todo de falsa posici√≥n 
    f: funci√≥n 
    a, b: intervalo inicial [a, b] 
    tol: tolerancia 
    max_iter: n√∫mero m√°ximo de iteraciones 
    """ 
    print("\n=== M√âTODO DE LA FALSA POSICI√ìN ===") 
    
    # Verificar que hay cambio de signo 
    if f(a) * f(b) > 0: 
        print("Error: f(a) y f(b) deben tener signos opuestos") 
        return None 
     
    print(f"{'Iter':<6} {'a':<15} {'b':<15} {'c':<15} {'f(c)':<15} {'Error':<15}") 
    print("-" * 95) 
     
    c_anterior = a 
     
    for i in range(max_iter): 
        fa = f(a) 
        fb = f(b) 
        
        # F√≥rmula de la falsa posici√≥n 
        c = (a * fb - b * fa) / (fb - fa) 
        fc = f(c) 
        
        if i > 0: 
            error = abs(c - c_anterior) 
        else: 
            error = abs(b - a) 
        
        print(f"{i+1:<6} {a:<15.8f} {b:<15.8f} {c:<15.8f} {fc:<15.8e} {error:<15.8e}") 
        
        if error < tol or abs(fc) < tol: 
            print(f"\nConvergi√≥ en {i+1} iteraciones") 
            print(f"Ra√≠z aproximada: x = {c:.8f}") 
            return c 
        
        # Actualizar intervalo 
        if fa * fc < 0: 
            b = c 
        else: 
            a = c 
        
        c_anterior = c 
    
    print(f"\nNo convergi√≥ en {max_iter} iteraciones") 
    return c 
# Ejemplo de uso: Encontrar ra√≠z de x^2 - 2 = 0 
def f(x): 
return x**2 - 2 
# Ejecutar 
raiz = falsa_posicion(f, 1, 2)</code></pre>
                </div>
                
                <div class="botones-container">
                    <a href="#" class="btn-ver-pdf">üìÑ Ver PDF</a>
                    <a href="#" class="btn-descargar" download>üì• Descargar PDF</a>
                </div>
            </div>

            <!-- Trabajo 6 -->
            <div class="trabajo-card">
                <h3>Trabajo 6: GRADIENTE DE UNA FUNCION</h3>
                <div class="etiqueta">R</div>
                <div class="etiqueta">con 1 variable</div>
                <p>El m√©todo de la gradiente es una t√©cnica que busca el valor que minimiza una funci√≥n avanzando paso a paso en la direcci√≥n donde esta disminuye m√°s r√°pido. Usa la pendiente de la funci√≥n para guiar el camino hacia el m√≠nimo. Es simple, eficiente y muy usado en optimizaci√≥n.</p>
                
                <button class="btn-toggle-codigo" onclick="toggleCodigo('codigo6')">Ver C√≥digo</button>
                
                <div id="codigo6" class="codigo-container codigo-oculto">
                    <pre><code># -------------------------------------
# M√âTODO DEL GRADIENTE CON INFORME
# -------------------------------------

# Funci√≥n objetivo (puedes cambiarla)
f <- function(x) {
return( (x - 3)^2 + 4 )
}

# Derivada (gradiente)
grad_f <- function(x) {
  return( 2 * (x - 3) )
}

# M√©todo del gradiente con impresi√≥n de iteraciones
gradient_descent <- function(x_inicial, tasa_aprendizaje = 0.1, max_iter = 50) {

x <- x_inicial

cat("INICIO DEL M√âTODO DEL GRADIENTE\n")
cat("Valor inicial: ", x, "\n")
cat("------------------------------------------\n")

for (i in 1:max_iter) {
    
    gradiente <- grad_f(x)
    x_nuevo <- x - tasa_aprendizaje * gradiente
    
    cat("Iteraci√≥n", i, ": x =", x_nuevo, " | gradiente =", gradiente, "\n")
    
    # Si el cambio es muy peque√±o, paramos
    if (abs(x_nuevo - x) < 1e-6) {
    cat("\nConvergencia alcanzada en", i, "iteraciones.\n")
    return(list(minimo_aprox = x_nuevo, iteraciones = i))
    }
    
    x <- x_nuevo
}

cat("\nM√°ximo de iteraciones alcanzado: ", max_iter, "\n")

return(list(minimo_aprox = x, iteraciones = max_iter))
}

# -------------------------------------
# EJECUCI√ìN
# -------------------------------------
resultado <- gradient_descent(
x_inicial = 10,
tasa_aprendizaje = 0.1,
max_iter = 40
)

cat("\n------------------------------------------\n")
cat("M√≠nimo aproximado: ", resultado$minimo_aprox, "\n")
cat("Iteraciones usadas: ", resultado$iteraciones, "\n")</code></pre>
                </div>
                
                <div class="botones-container">
                    <a href="#" class="btn-ver-pdf">üìÑ Ver PDF</a>
                    <a href="#" class="btn-descargar" download>üì• Descargar PDF</a>
                </div>
            </div>

            <!-- Trabajo 7 -->
            <div class="trabajo-card">
                <h3>Trabajo 7: ANALISIS DEL ARTICULO</h3>
                <div class="etiqueta">R</div>
                <div class="etiqueta">diferencias </div>
                <p>El objetivo de esta prueba fue evaluar la eficiencia computacional del m√©todo de regresi√≥n lineal de R (lm) en comparaci√≥n con el algoritmo de gradiente descendente. Se emplearon conjuntos de datos de diferentes tama√±os (100 a 10,000 observaciones) y se registraron el tiempo de ejecuci√≥n (en segundos) y el uso de memoria (en bytes) mediante la librer√≠a bench. Ambos m√©todos fueron implementados bajo las mismas condiciones para garantizar una comparaci√≥n justa.</p>
                
                <button class="btn-toggle-codigo" onclick="toggleCodigo('codigo7a')">Ver C√≥digo 1</button>
                <button class="btn-toggle-codigo" onclick="toggleCodigo('codigo7b')">Ver C√≥digo 2</button>
                
                <div id="codigo7a" class="codigo-container codigo-oculto">
                    <pre><code>f  
<- function(x) (x + 1)^2 
df <- function(x) 2 * (x + 1) 
x <- 5 
alpha <- 0.3 
tol <- 1e-6 
max_iter <- 20 
iter <- 0 
historial <- data.frame(iter = numeric(), x = numeric(), f_x = numeric()) 
repeat { 
iter <- iter + 1 
grad <- df(x) 
x_new <- x - alpha * grad 
historial <- rbind(historial, data.frame(iter = iter, x = x_new, f_x = f(x_new))) 
if (abs(grad) < tol || iter >= max_iter) break 
x <- x_new 
} 
# Resultado final 
cat("      
RESULTADOS DEL M√âTODO DEL GRADIENTE\n") 
cat("----------------------------------------\n") 
cat("  
cat("  
Iteraciones realizadas:", iter, "\n") 
M√≠nimo aproximado en x =", round(x_new, 6), "\n") 
cat("  
Valor m√≠nimo f(x) =", round(f(x_new), 6), "\n\n") 
cat("  
Tabla de iteraciones:\n") 
print(historial) 
plot(historial$iter, historial$f_x, type = "o", pch = 19, col = "blue", 
main = "Convergencia del M√©todo del Gradiente (f(x) = (x + 1)^2)", 
xlab = "Iteraciones", ylab = "f(x)") 
grid()</code></pre>
                </div>

                <div id="codigo7b" class="codigo-container codigo-oculto">
                    <pre><code># Instalaci√≥n de profvis si no lo tienes 
# install.packages("profvis") 
library(profvis) 
# Datos simulados 
set.seed(123) 
n <- 10000 
x <- runif(n, 0, 10) 
y <- 3*x + 5 + rnorm(n, 0, 2) 
#  Funci√≥n OLS 
ols_fun <- function(x, y) { 
modelo <- lm(y ~ x) 
return(modelo) 
} 
#  Funci√≥n Gradient Descent 
gd_fun <- function(x, y, alpha = 0.00001, iter_max = 5000) { 
m <- 0 
b <- 0 
n <- length(y) 
for (i in 1:iter_max) { 
y_pred <- m*x + b 
dm <- (-2/n) * sum(x * (y - y_pred)) 
db <- (-2/n) * sum(y - y_pred) 
m <- m - alpha * dm 
b <- b - alpha * db 
} 
return(list(m = m, b = b)) 
} 
#  Medimos el tiempo de procesamiento 
cat("==== M√âTODO OLS ====\n") 
tiempo_ols <- system.time({ 
modelo_ols <- ols_fun(x, y) 
}) 
print(tiempo_ols) 
cat("\n==== M√âTODO GRADIENTE DESCENDENTE ====\n") 
tiempo_gd <- system.time({ 
modelo_gd <- gd_fun(x, y) 
}) 
print(tiempo_gd) 
cat("\n RESULTADOS COMPARATIVOS:\n") 
cat("Tiempo OLS: ", round(tiempo_ols["elapsed"], 5), "segundos\n") 
cat("Tiempo GD : ", round(tiempo_gd["elapsed"], 5), "segundos\n") 
cat("\nCoeficientes:\n") 
cat("OLS -> pendiente:", coef(modelo_ols)[2], " intercepto:", coef(modelo_ols)[1], "\n") 
cat("GD  -> pendiente:", modelo_gd$m, " intercepto:", modelo_gd$b, "\n") 
profvis({ 
ols_fun(x, y) 
gd_fun(x, y) 
})</code></pre>
                </div>
                
                <div class="botones-container">
                    <a href="#" class="btn-ver-pdf">üìÑ Ver PDF</a>
                    <a href="#" class="btn-descargar" download>üì• Descargar PDF</a>
                </div>
            </div>

            <!-- Trabajo 8 -->
            <div class="trabajo-card">
                <h3>Trabajo 8: JUEGO DE SUPERVIVENCIA</h3>
                <div class="etiqueta">R</div>
                <div class="etiqueta">bucles y iteraciones</div>
                <p>El siguiente trabajo presenta la simulaci√≥n de un juego cooperativo en el que varios jugadores comparten una bolsa de caramelos de tres tipos: A, B y C. El objetivo es que, mediante combinaciones e intercambios, el grupo logre formar al menos un chupet√≠n (D) por cada jugador.</p>
                
                <button class="btn-toggle-codigo" onclick="toggleCodigo('codigo8')">Ver C√≥digo</button>
                
                <div id="codigo8" class="codigo-container codigo-oculto">
                    <pre><code>------------------------------------------------------------------------------------------------------------------------------ 
set.seed(123) 
 
# Funci√≥n de simulaci√≥n 
simular_paletas <- function() { 
  # Cada estudiante tiene conteo de A, B, C y Paletas (P) 
  estudiantes <- vector("list", 9) 
  for (i in 1:9) estudiantes[[i]] <- c(A=0, B=0, C=0, P=0) 
   
  iteraciones <- 0 
   
  while (TRUE) { 
    iteraciones <- iteraciones + 1 
     
    # Cada estudiante recibe 2 caramelos aleatorios 
    for (i in 1:9) { 
      nuevos <- sample(c("A", "B", "C"), 2, replace = TRUE) 
      for (candy in nuevos) estudiantes[[i]][candy] <- estudiantes[[i]][candy] + 1 
    } 
     
    # Evaluar canjes por paletas y posibles devoluciones 
    for (i in 1:9) { 
      # N√∫mero de tr√≠os A,B,C disponibles 
      sets <- min(estudiantes[[i]][c("A", "B", "C")]) 
       
      if (sets >= 2) { 
        # Dos sets: 1 paleta + 1 caramelo aleatorio 
        estudiantes[[i]]["P"] <- estudiantes[[i]]["P"] + 1 
        estudiantes[[i]][c("A","B","C")] <- estudiantes[[i]][c("A","B","C")] - 2 
        bonus <- sample(c("A", "B", "C"), 1) 
        estudiantes[[i]][bonus] <- estudiantes[[i]][bonus] + 1 
      } else if (sets == 1) { 
        # Un set: 1 paleta 
        estudiantes[[i]]["P"] <- estudiantes[[i]]["P"] + 1 
        estudiantes[[i]][c("A","B","C")] <- estudiantes[[i]][c("A","B","C")] - 1 
    } 
    
    # Si devuelve una paleta, recibe 3 caramelos aleatorios 
    if (estudiantes[[i]]["P"] >= 1 && runif(1) < 0.3) {  # 30% de probabilidad 
        estudiantes[[i]]["P"] <- estudiantes[[i]]["P"] - 1 
        devolucion <- sample(c("A","B","C"), 3, replace = TRUE) 
        for (candy in devolucion) estudiantes[[i]][candy] <- estudiantes[[i]][candy] + 1  } 
    } 
    
    # Verificar si los 9 tienen al menos una paleta 
    paletas_totales <- sapply(estudiantes, function(e) e["P"]) 
    if (all(paletas_totales >= 1)) break 
} 

return(iteraciones) 
} 

# Ejecutar simulaciones 
n_rep <- 300 
resultados <- replicate(n_rep, simular_paletas()) 

# Resultados 
cat("Promedio de iteraciones necesarias:", mean(resultados), "\n") 

# Visualizaci√≥n 
hist(resultados,  
main="Distribuci√≥n de iteraciones necesarias", 
xlab="Iteraciones",  
col="lightgreen", border="white")</code></pre>
                </div>
                
                <div class="botones-container">
                    <a href="#" class="btn-ver-pdf">üìÑ Ver PDF</a>
                    <a href="#" class="btn-descargar" download>üì• Descargar PDF</a>
                </div>
            </div>

            <!-- Trabajo 9 -->
            <div class="trabajo-card">
                <h3>Trabajo 9: RESUMEN DEL ARTICULO</h3>
                <div class="etiqueta">R</div>
                <div class="etiqueta">RESUMEN</div>
                <p>El art√≠culo aborda uno de los principales retos en el procesamiento de im√°genes m√©dicas: el registro preciso de im√°genes deformadas. Este proceso permite alinear m√∫ltiples im√°genes de un mismo paciente, obtenidas en distintas modalidades o momentos, para mejorar el diagn√≥stico, el seguimiento de enfermedades y la planificaci√≥n de tratamientos. Aunque las transformaciones r√≠gidas (traslaci√≥n y rotaci√≥n) son √∫tiles en casos simples, la mayor√≠a de escenarios cl√≠nicos requieren m√©todos no r√≠gidos capaces de modelar deformaciones anat√≥micas complejas.</p>
                <div class="botones-container">
                    <a href="#" class="btn-ver-pdf">üìÑ Ver PDF</a>
                    <a href="#" class="btn-descargar" download>üì• Descargar PDF</a>
                </div>
            </div>

            <!-- Trabajo 10 -->
            <div class="trabajo-card">
                <h3>Trabajo 10: DIFERENCIACION NUMERICA</h3>
                <div class="etiqueta">R</div>
                <p>La diferenciaci√≥n num√©rica permite aproximar la derivada de una funci√≥n a partir de valores discretos, es decir, mediante datos tabulados o resultados experimentales. Matem√°ticamente, </p>
                
                
                <div class="botones-container">
                    <a href="#" class="btn-ver-pdf">üìÑ Ver PDF</a>
                    <a href="#" class="btn-descargar" download>üì• Descargar PDF</a>
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleCodigo(id) {
            const elemento = document.getElementById(id);
            if (elemento.classList.contains('codigo-oculto')) {
                elemento.classList.remove('codigo-oculto');
            } else {
                elemento.classList.add('codigo-oculto');
            }
        }
    </script>
</body>
</html>
